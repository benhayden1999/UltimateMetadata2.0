"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseGPSLocation = parseGPSLocation;
const CoordinateParser_1 = require("./CoordinateParser");
const Number_1 = require("./Number");
const Pick_1 = require("./Pick");
const String_1 = require("./String");
const MAX_LAT_LON_DIFF = 1;
function parsePosition(position) {
    if ((0, String_1.blank)(position))
        return;
    const [lat, lon] = (0, String_1.toS)(position).split(/[, ]+/).map(Number_1.toFloat);
    return lat != null && lon != null ? [lat, lon] : undefined;
}
function processCoordinate(config, warnings) {
    let { value, ref } = config;
    const { geoValue, coordinateType } = config;
    const { expectedRefPositive, expectedRefNegative, max } = config;
    let isInvalid = false;
    ref =
        ref?.trim().toUpperCase().slice(0, 1) ??
            (value < 0 ? expectedRefNegative : expectedRefPositive);
    // Check range
    if (Math.abs(value) > max) {
        isInvalid = true;
        warnings.push(`Invalid GPS${coordinateType}: ${value} is out of range`);
        return { value, ref, isInvalid };
    }
    // Apply hemisphere reference
    if (ref === expectedRefNegative) {
        value = -Math.abs(value);
    }
    // Check for mismatched signs with GeolocationPosition
    if (geoValue != null &&
        Math.abs(Math.abs(geoValue) - Math.abs(value)) < MAX_LAT_LON_DIFF) {
        if (Math.sign(geoValue) !== Math.sign(value)) {
            value = -value;
            warnings.push(`Corrected GPS${coordinateType} sign based on GeolocationPosition`);
        }
        // Force ref to correct value
        const expectedRef = geoValue < 0 ? expectedRefNegative : expectedRefPositive;
        if (ref !== expectedRef) {
            ref = expectedRef;
            warnings.push(`Corrected GPS${coordinateType}Ref to ${expectedRef} based on GeolocationPosition`);
        }
    }
    // Ensure ref matches coordinate sign
    const expectedRef = value < 0 ? expectedRefNegative : expectedRefPositive;
    if (ref != null && ref !== expectedRef) {
        warnings.push(`Corrected GPS${coordinateType}Ref to ${ref} to match coordinate sign`);
    }
    ref = expectedRef;
    return { value, ref, isInvalid };
}
function parseGPSLocation(tags, opts) {
    let parsed = false;
    const warnings = [];
    const result = (0, Pick_1.pick)(tags, "GPSLatitude", "GPSLatitudeRef", "GPSLongitude", "GPSLongitudeRef");
    if ((0, String_1.notBlankString)(tags.GPSPosition)) {
        try {
            const pos = (0, CoordinateParser_1.parseCoordinates)(tags.GPSPosition);
            if (opts.ignoreZeroZeroLatLon === true &&
                pos.latitude === 0 &&
                pos.longitude === 0) {
                warnings.push("Ignoring zero coordinates from GPSPosition");
            }
            else {
                parsed = true;
                result.GPSLatitude = pos.latitude;
                result.GPSLongitude = pos.longitude;
                result.GPSLatitudeRef = pos.latitude < 0 ? "S" : "N";
                result.GPSLongitudeRef = pos.longitude < 0 ? "W" : "E";
            }
        }
        catch (e) {
            warnings.push("Error parsing GPSPosition: " + e);
        }
    }
    // Are both GPSLatitude and GPSLongitude available?
    if (!parsed && (0, String_1.notBlankString)(tags.GPSLatitude) && (0, String_1.notBlankString)(tags.GPSLongitude)) {
        try {
            const lat = (0, CoordinateParser_1.parseCoordinate)(tags.GPSLatitude);
            const lon = (0, CoordinateParser_1.parseCoordinate)(tags.GPSLongitude);
            if (opts.ignoreZeroZeroLatLon === true &&
                lat.degrees === 0 &&
                lon.degrees === 0) {
                warnings.push("Ignoring zero coordinates from GPSLatitude/GPSLongitude");
                return { invalid: true, warnings };
            }
            else {
                result.GPSLatitude = lat.degrees;
                result.GPSLongitude = lon.degrees;
                result.GPSLatitudeRef = lat.direction;
                result.GPSLongitudeRef = lon.direction;
            }
        }
        catch (e) {
            warnings.push(`Error parsing GPSLatitude or GPSLongitude: ` + e);
        }
    }
    // Early return if no GPS data
    if (!(0, Number_1.isNumber)(result.GPSLatitude) && !(0, Number_1.isNumber)(result.GPSLongitude)) {
        return {};
    }
    // Check for zero coordinates when ignoreZeroZeroLatLon is true
    if (opts.ignoreZeroZeroLatLon === true &&
        result.GPSLatitude === 0 &&
        result.GPSLongitude === 0) {
        warnings.push("Ignoring zero GPSLatitude and GPSLongitude");
        return { invalid: true, warnings };
    }
    // Parse GeolocationPosition
    const [geoLat, geoLon] = parsePosition(tags.GeolocationPosition) ?? [
        undefined,
        undefined,
    ];
    let isInvalid = false;
    // Process latitude
    if ((0, Number_1.isNumber)(result.GPSLatitude)) {
        const latitudeResult = processCoordinate({
            value: result.GPSLatitude,
            ref: result.GPSLatitudeRef,
            geoValue: geoLat,
            expectedRefPositive: "N",
            expectedRefNegative: "S",
            max: 90,
            coordinateType: "Latitude",
        }, warnings);
        result.GPSLatitude = latitudeResult.value;
        result.GPSLatitudeRef = latitudeResult.ref;
        isInvalid = isInvalid || latitudeResult.isInvalid;
    }
    // Process longitude
    if ((0, Number_1.isNumber)(result.GPSLongitude)) {
        const longitudeResult = processCoordinate({
            value: result.GPSLongitude,
            ref: result.GPSLongitudeRef,
            geoValue: geoLon,
            expectedRefPositive: "E",
            expectedRefNegative: "W",
            max: 180,
            coordinateType: "Longitude",
        }, warnings);
        result.GPSLongitude = longitudeResult.value;
        result.GPSLongitudeRef = longitudeResult.ref;
        isInvalid = isInvalid || longitudeResult.isInvalid;
    }
    return isInvalid
        ? { invalid: true, warnings }
        : { result, invalid: false, warnings };
}
//# sourceMappingURL=GPS.js.map